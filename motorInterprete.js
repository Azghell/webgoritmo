// motorInterprete.js - Bloque 6.1 Corregido (SubProcesos + Limpieza Comentarios + DEBUG LEER)

window.Webgoritmo = window.Webgoritmo || {};
Webgoritmo.Interprete = Webgoritmo.Interprete || {};

// --- FUNCIÓN DE UTILIDAD INTERNA ---
function limpiarComentariosDeExpresion(exprStr) {
    if (typeof exprStr !== 'string') return exprStr;
    const idxComentario = exprStr.indexOf('//');
    if (idxComentario !== -1) {
        exprStr = exprStr.substring(0, idxComentario);
    }
    return exprStr.trim();
}

// --- FUNCIONES DE UTILIDAD DEL INTÉRPRETE (sin cambios desde Bloque 5) ---
Webgoritmo.Interprete.obtenerValorPorDefecto = function(tipo) { /* ... */ };
Webgoritmo.Interprete.inferirTipo = function(valor) { /* ... */ };
Webgoritmo.Interprete.convertirValorParaAsignacion = function(valor, tipoDestino) { /* ... */ };
Webgoritmo.Interprete.inicializarArray = function(dimensions, baseType) { /* ... */ };
Webgoritmo.Interprete.parseDefinicionSubProceso = function(lineaInicioSubProceso, indiceInicio, todasLasLineas) { /* ... (como en Bloque 6.1) ... */ };

// --- HANDLERS DE INSTRUCCIONES (ACTUALIZADOS para limpiar comentarios donde sea necesario) ---
Webgoritmo.Interprete.handleDefinir = async function(linea, ambitoActual, numLineaOriginal) { /* ... (como en corrección anterior) ... */ };
Webgoritmo.Interprete.handleDimension = async function(linea, ambitoActual, numLineaOriginal) { /* ... (como en corrección anterior) ... */ };
Webgoritmo.Interprete.handleEscribir = async function(linea, ambitoActual, numLineaOriginal) { /* ... (como en corrección anterior) ... */ };
Webgoritmo.Interprete.handleAsignacion = async function(linea, ambitoActual, numLineaOriginal) { /* ... (como en corrección anterior) ... */ };
Webgoritmo.Interprete.handleLeer = async function(linea, ambitoActual, numLineaOriginal) { /* ... (como en Bloque 4) ... */ };
Webgoritmo.Interprete.handleSi = async function(lineaActual, ambitoActual, numLineaOriginalSi, lineasBloqueCompleto, indiceSiEnBloque) { /* ... (como en corrección anterior) ... */};

Webgoritmo.Interprete.ejecutarSubProcesoLlamada = async function(nombreFuncionOriginal, listaExprArgumentosStr, ambitoLlamador, numLineaOriginalLlamada) { /* ... (como en Bloque 6.1) ... */ };

// --- LÓGICA DE EJECUCIÓN (ACTUALIZADA con DEBUG para LEER) ---
Webgoritmo.Interprete.ejecutarBloque = async function(lineasBloqueParam, ambitoActual, numLineaOriginalOffset = 0) {
    if (!Webgoritmo.estadoApp || !Webgoritmo.Interprete || !Webgoritmo.UI || !Webgoritmo.Expresiones) { console.error("ejecutarBloque: Módulos esenciales no definidos."); return; }
    if (Webgoritmo.UI.añadirSalida) Webgoritmo.UI.añadirSalida(`ejecutarBloque (Debug Leer) procesando ${lineasBloqueParam.length} líneas. Offset: ${numLineaOriginalOffset}`, 'debug');

    let i = 0;
    while (i < lineasBloqueParam.length) {
        if (Webgoritmo.estadoApp.detenerEjecucion) {
            if (Webgoritmo.UI.añadirSalida) Webgoritmo.UI.añadirSalida("Ejecución detenida en ejecutarBloque.", "debug");
            break;
        }

        const lineaOriginal = lineasBloqueParam[i];
        const lineaOriginalTrimmed = lineaOriginal.trim();
        const lineaParaAnalisis = limpiarComentariosDeExpresion(lineaOriginalTrimmed);

        if (lineaParaAnalisis === '') {
            i++;
            continue;
        }

        const numLineaGlobal = numLineaOriginalOffset + i + 1;
        Webgoritmo.estadoApp.currentLineInfo = { numLineaOriginal: numLineaGlobal, contenido: lineaParaAnalisis };
        if (Webgoritmo.UI.añadirSalida) Webgoritmo.UI.añadirSalida(`L${numLineaGlobal}: ${lineaParaAnalisis}`, 'debug');

        // DEBUG LOGS PARA LEER
        const lineaLowerParaDeteccion = lineaParaAnalisis.toLowerCase();
        console.log(`[DEBUG ejecutarBloque L${numLineaGlobal}] lineaParaAnalisis: "${lineaParaAnalisis}"`);
        console.log(`[DEBUG ejecutarBloque L${numLineaGlobal}] lineaLowerParaDeteccion: "${lineaLowerParaDeteccion}"`);
        console.log(`[DEBUG ejecutarBloque L${numLineaGlobal}] Test startsWith('leer '): ${lineaLowerParaDeteccion.startsWith('leer ')}`);
        console.log(`[DEBUG ejecutarBloque L${numLineaGlobal}] Char codes: ${lineaLowerParaDeteccion.split('').map(c => c.charCodeAt(0)).join(',')}`);


        let instruccionManejada = false;
        try {
            const matchAsignacion = lineaParaAnalisis.match(/^([a-zA-Z_áéíóúÁÉÍÓÚñÑ][a-zA-Z0-9_áéíóúÁÉÍÓÚñÑ]*(?:\s*\[.+?\])?)\s*(?:<-|=)/);
            const matchLlamadaSubProceso = lineaParaAnalisis.match(/^([a-zA-Z_áéíóúÁÉÍÓÚñÑ][a-zA-Z0-9_áéíóúÁÉÍÓÚñÑ]*)\s*\((.*?)\)\s*$/);

            if (lineaLowerParaDeteccion.startsWith('definir ')) {
                 instruccionManejada = await Webgoritmo.Interprete.handleDefinir(lineaParaAnalisis, ambitoActual, numLineaGlobal);
            } else if (lineaLowerParaDeteccion.startsWith('dimension ') || lineaLowerParaDeteccion.startsWith('dimensionar ')) {
                 instruccionManejada = await Webgoritmo.Interprete.handleDimension(lineaParaAnalisis, ambitoActual, numLineaGlobal);
            } else if (lineaLowerParaDeteccion.startsWith('escribir ') || lineaLowerParaDeteccion.startsWith('imprimir ') || lineaLowerParaDeteccion.startsWith('mostrar ')) {
                 instruccionManejada = await Webgoritmo.Interprete.handleEscribir(lineaParaAnalisis, ambitoActual, numLineaGlobal);
            } else if (lineaLowerParaDeteccion.startsWith('leer ')) {
                 console.log(`[DEBUG ejecutarBloque L${numLineaGlobal}] ¡ENTRÓ AL BLOQUE IF PARA LEER!`);
                 instruccionManejada = await Webgoritmo.Interprete.handleLeer(lineaParaAnalisis, ambitoActual, numLineaGlobal);
            } else if (lineaLowerParaDeteccion.startsWith('si ') && lineaLowerParaDeteccion.endsWith(' entonces')) {
                 const indiceFinSiRelativo = await Webgoritmo.Interprete.handleSi(lineaParaAnalisis, ambitoActual, numLineaGlobal, lineasBloqueParam, i);
                 i = indiceFinSiRelativo;
                 instruccionManejada = true;
            }
            else if (matchAsignacion) {
                 instruccionManejada = await Webgoritmo.Interprete.handleAsignacion(lineaParaAnalisis, ambitoActual, numLineaGlobal);
            } else if (matchLlamadaSubProceso) {
                const nombreFuncionLlamada = matchLlamadaSubProceso[1];
                const argsStrLlamada = matchLlamadaSubProceso[2].trim();
                let argExprsLlamada = [];
                if (argsStrLlamada !== "") {
                    argExprsLlamada = argsStrLlamada.split(',').map(arg => limpiarComentariosDeExpresion(arg.trim()));
                }
                console.log(`[DEBUG ejecutarBloque L${numLineaGlobal}] matchLlamadaSubProceso ÉXITO. Nombre crudo: ${matchLlamadaSubProceso[1]}`);
                const nombreFuncionLlamada = matchLlamadaSubProceso[1];
                const argsStrLlamada = matchLlamadaSubProceso[2].trim();
                let argExprsLlamada = [];
                if (argsStrLlamada !== "") {
                    argExprsLlamada = argsStrLlamada.split(',').map(arg => limpiarComentariosDeExpresion(arg.trim()));
                }

                console.log(`[DEBUG ejecutarBloque L${numLineaGlobal}] Intentando llamar a: '${nombreFuncionLlamada}', toLowerCase: '${nombreFuncionLlamada.toLowerCase()}'`);
                console.log(`[DEBUG ejecutarBloque L${numLineaGlobal}] funcionesDefinidas tiene '${nombreFuncionLlamada.toLowerCase()}': ${Webgoritmo.estadoApp.funcionesDefinidas && Webgoritmo.estadoApp.funcionesDefinidas.hasOwnProperty(nombreFuncionLlamada.toLowerCase())}`);
                try {
                    console.log(`[DEBUG ejecutarBloque L${numLineaGlobal}] Contenido de funcionesDefinidas (claves):`, JSON.stringify(Object.keys(Webgoritmo.estadoApp.funcionesDefinidas || {})));
                } catch (e) { console.error("Error stringifying funcionesDefinidas keys", e); }


                if (Webgoritmo.estadoApp.funcionesDefinidas && Webgoritmo.estadoApp.funcionesDefinidas.hasOwnProperty(nombreFuncionLlamada.toLowerCase())) {
                    console.log(`[DEBUG ejecutarBloque L${numLineaGlobal}] ENTRANDO a llamar Webgoritmo.Interprete.ejecutarSubProcesoLlamada para '${nombreFuncionLlamada}'`);
                    await Webgoritmo.Interprete.ejecutarSubProcesoLlamada(nombreFuncionLlamada, argExprsLlamada, ambitoActual, numLineaGlobal);
                    console.log(`[DEBUG ejecutarBloque L${numLineaGlobal}] SALIENDO de llamar Webgoritmo.Interprete.ejecutarSubProcesoLlamada para '${nombreFuncionLlamada}'`);
                    instruccionManejada = true;
                } else {
                    console.log(`[DEBUG ejecutarBloque L${numLineaGlobal}] SubProceso '${nombreFuncionLlamada}' NO encontrado en funcionesDefinidas.`);
                }
            }

            const palabrasClaveDeBloque = /^(finsi|sino|finmientras|finpara|finsubproceso|finsegun|hasta que|proceso|algoritmo|finproceso|finalgoritmo)$/;
            if (!instruccionManejada && lineaParaAnalisis && !palabrasClaveDeBloque.test(lineaLowerParaDeteccion.split(/\s+/)[0])) {
                 if (Webgoritmo.UI.añadirSalida) Webgoritmo.UI.añadirSalida(`Instrucción no reconocida: '${lineaParaAnalisis}' (L${numLineaGlobal})`, 'warning');
            }
        } catch (e) { Webgoritmo.estadoApp.errorEjecucion = e.message.includes(`L${numLineaGlobal}`)?e.message:`Error L${numLineaGlobal}: ${e.message}`; Webgoritmo.estadoApp.detenerEjecucion=true; if(Webgoritmo.UI&&Webgoritmo.UI.añadirSalida)Webgoritmo.UI.añadirSalida(Webgoritmo.estadoApp.errorEjecucion,'error'); else console.error(Webgoritmo.estadoApp.errorEjecucion); break; }

        if (Webgoritmo.estadoApp.detenerEjecucion) {
            if (Webgoritmo.UI.añadirSalida) Webgoritmo.UI.añadirSalida("Deteniendo ejecución después de manejar instrucción.", "debug");
            break;
        }
        i++;
    }
    Webgoritmo.estadoApp.currentLineInfo = null;
};

Webgoritmo.Interprete.ejecutarPseudocodigo = async function() {
    if (!Webgoritmo.UI || !Webgoritmo.UI.añadirSalida) { console.error("UI.añadirSalida no disponible."); return; }
    if (!Webgoritmo.Editor || !Webgoritmo.Editor.editorCodigo) { Webgoritmo.UI.añadirSalida("Error: Editor no listo.", "error"); return; }
    if (!Webgoritmo.estadoApp) { Webgoritmo.UI.añadirSalida("Error: estadoApp no listo.", "error"); return; }
    if (!Webgoritmo.Expresiones) { Webgoritmo.UI.añadirSalida("Error: Evaluador de expresiones no listo.", "error"); return; }
    if (Webgoritmo.DOM && Webgoritmo.DOM.consolaSalida) Webgoritmo.DOM.consolaSalida.innerHTML = '';
    Webgoritmo.UI.añadirSalida("--- Iniciando ejecución (Debug SubP Llamada) ---", "normal"); // Mensaje de log actualizado
    Webgoritmo.estadoApp.variables = {}; Webgoritmo.estadoApp.detenerEjecucion = false; Webgoritmo.estadoApp.errorEjecucion = null;
    Webgoritmo.estadoApp.esperandoEntrada = false; Webgoritmo.estadoApp.resolverPromesaEntrada = null; Webgoritmo.estadoApp.promesaEntradaPendiente = null;
    Webgoritmo.estadoApp.pilaLlamadas = [];
    Webgoritmo.estadoApp.lineasCodigo = Webgoritmo.Editor.editorCodigo.getValue().split('\n');
    Webgoritmo.estadoApp.funcionesDefinidas = {}; const subProcesoLineIndices = new Set();
    // ... (resto igual)
    if (Webgoritmo.Interprete.parseDefinicionSubProceso) { for (let i = 0; i < Webgoritmo.estadoApp.lineasCodigo.length; i++) { const lineaOriginal = Webgoritmo.estadoApp.lineasCodigo[i]; let lineaParaAnalisis = limpiarComentariosDeExpresion(lineaOriginal.split('//')[0].trim()); if (lineaParaAnalisis.startsWith('/*') && lineaParaAnalisis.endsWith('*/')) lineaParaAnalisis = ''; const lineaLower = lineaParaAnalisis.toLowerCase(); if (lineaLower.startsWith("subproceso")) { try { const defSubProceso = Webgoritmo.Interprete.parseDefinicionSubProceso(lineaOriginal, i, Webgoritmo.estadoApp.lineasCodigo); if (Webgoritmo.estadoApp.funcionesDefinidas.hasOwnProperty(defSubProceso.nombreLc)) throw new Error(`SubProceso '${defSubProceso.nombreOriginal}' ya definido.`); Webgoritmo.estadoApp.funcionesDefinidas[defSubProceso.nombreLc] = defSubProceso; for (let k = i; k <= defSubProceso.indiceFinEnTodasLasLineas; k++) subProcesoLineIndices.add(k); i = defSubProceso.indiceFinEnTodasLasLineas; if (Webgoritmo.UI.añadirSalida) Webgoritmo.UI.añadirSalida(`SubProceso '${defSubProceso.nombreOriginal}' parseado (L${defSubProceso.lineaOriginalDef}). Parámetros: ${defSubProceso.parametros.map(p=>p.nombreOriginal + (p.esPorReferencia ? " PorRef" : "")).join(', ') || 'ninguno'}`, 'debug'); } catch (e) { Webgoritmo.estadoApp.errorEjecucion = e.message; Webgoritmo.estadoApp.detenerEjecucion = true; break; } } if (Webgoritmo.estadoApp.detenerEjecucion) break; } }
    if (Webgoritmo.estadoApp.detenerEjecucion) { if (Webgoritmo.UI.añadirSalida) { Webgoritmo.UI.añadirSalida(Webgoritmo.estadoApp.errorEjecucion, 'error'); Webgoritmo.UI.añadirSalida("--- Ejecución con errores (Parseo SubProcesos) ---", "error");} return; }
    let lineasDelPrincipal = []; let inicioBloquePrincipalLineaNum = -1; let processingState = 'buscar_inicio'; for (let j = 0; j < Webgoritmo.estadoApp.lineasCodigo.length; j++) { if (subProcesoLineIndices.has(j)) continue; const lineaOriginal = Webgoritmo.estadoApp.lineasCodigo[j]; let lineaParaAnalisis = limpiarComentariosDeExpresion(lineaOriginal.split('//')[0].trim()); if (lineaParaAnalisis.startsWith('/*') && lineaParaAnalisis.endsWith('*/')) lineaParaAnalisis = ''; const lineaLower = lineaParaAnalisis.toLowerCase(); if (processingState === 'buscar_inicio') { if (lineaLower.startsWith("proceso") || lineaLower.startsWith("algoritmo")) { inicioBloquePrincipalLineaNum = j + 1; processingState = 'en_bloque';} else if (lineaParaAnalisis !== "") { Webgoritmo.estadoApp.errorEjecucion = `Error L${j+1}: Código fuera de bloque.`; Webgoritmo.estadoApp.detenerEjecucion = true; break;} } else if (processingState === 'en_bloque') { if (lineaLower.startsWith("finproceso") || lineaLower.startsWith("finalgoritmo")) processingState = 'bloque_terminado'; else if (lineaLower.startsWith("proceso") || lineaLower.startsWith("algoritmo")) { Webgoritmo.estadoApp.errorEjecucion = `Error L${j+1}: Bloques anidados no permitidos.`; Webgoritmo.estadoApp.detenerEjecucion = true; break;} else lineasDelPrincipal.push(lineaOriginal); } else if (processingState === 'bloque_terminado') { if (lineaParaAnalisis !== "") { Webgoritmo.estadoApp.errorEjecucion = `Error L${j+1}: Código después de FinAlgoritmo.`; Webgoritmo.estadoApp.detenerEjecucion = true; break;} } }
    if (!Webgoritmo.estadoApp.errorEjecucion) { const tieneCodigoEfectivo = Webgoritmo.estadoApp.lineasCodigo.some((l, idx) => { if(subProcesoLineIndices.has(idx))return false; let t=limpiarComentariosDeExpresion(l.split('//')[0].trim()); if(t.startsWith('/*')&&t.endsWith('*/'))t=''; return t !== ''; }); if (processingState === 'buscar_inicio' && tieneCodigoEfectivo) Webgoritmo.estadoApp.errorEjecucion = "No se encontró bloque 'Algoritmo'/'Proceso'."; else if (processingState === 'en_bloque') Webgoritmo.estadoApp.errorEjecucion = `Bloque 'Algoritmo'/'Proceso' L${inicioBloquePrincipalLineaNum} no cerrado.`;}
    if (Webgoritmo.estadoApp.errorEjecucion) { if (Webgoritmo.UI.añadirSalida) Webgoritmo.UI.añadirSalida(Webgoritmo.estadoApp.errorEjecucion, 'error'); Webgoritmo.estadoApp.detenerEjecucion = true; } else if (inicioBloquePrincipalLineaNum !== -1 && processingState === 'bloque_terminado') { if (lineasDelPrincipal.length > 0) await Webgoritmo.Interprete.ejecutarBloque(lineasDelPrincipal, Webgoritmo.estadoApp.variables, inicioBloquePrincipalLineaNum -1 ); else if (Webgoritmo.UI.añadirSalida) Webgoritmo.UI.añadirSalida("Advertencia: Bloque principal vacío.", "warning"); } else { /* ... */ }
    if (Webgoritmo.UI.añadirSalida) { if (Webgoritmo.estadoApp.errorEjecucion) Webgoritmo.UI.añadirSalida("--- Ejecución con errores (Debug SubP Llamada) ---", "error"); else if (Webgoritmo.estadoApp.detenerEjecucion && !Webgoritmo.estadoApp.esperandoEntrada) Webgoritmo.UI.añadirSalida("--- Ejecución interrumpida (Debug SubP Llamada) ---", "warning");  else if (!Webgoritmo.estadoApp.esperandoEntrada) Webgoritmo.UI.añadirSalida("--- Ejecución finalizada (Debug SubP Llamada) ---", "normal");  }
    // ... (log de variables)
};

// --- Copiar las funciones de utilidad y handlers que no cambian ---
Webgoritmo.Interprete.obtenerValorPorDefecto = function(tipo) { const t = String(tipo).toLowerCase(); switch(t){case 'entero':return 0;case 'real':return 0.0;case 'logico':return false;case 'caracter':case 'cadena':return '';case 'numero':return 0;default:return null;}};
Webgoritmo.Interprete.inferirTipo = function(v){if(typeof v==='number')return Number.isInteger(v)?'entero':'real';if(typeof v==='boolean')return 'logico';if(typeof v==='string')return 'cadena';return 'desconocido';};
Webgoritmo.Interprete.convertirValorParaAsignacion = function(valor, tipoDestino) { const tipoDestinoLower=String(tipoDestino).toLowerCase();const tipoOrigen=Webgoritmo.Interprete.inferirTipo(valor).toLowerCase();if(tipoOrigen===tipoDestinoLower&&tipoDestinoLower!=='desconocido')return valor;if(tipoDestinoLower==='real'&&tipoOrigen==='entero')return parseFloat(valor);if(tipoDestinoLower==='numero'&&(tipoOrigen==='entero'||tipoOrigen==='real'))return valor;if(tipoDestinoLower==='cadena')return typeof valor==='boolean'?(valor?'Verdadero':'Falso'):String(valor);if(tipoDestinoLower==='caracter'&&typeof valor==='string')return valor.length>0?valor.charAt(0):'';if(typeof valor==='string'){const vt=valor.trim();switch(tipoDestinoLower){case 'entero':const iv=parseInt(vt,10);if(isNaN(iv)||!/^-?\d+$/.test(vt))throw new Error(`'${valor}' no es entero.`);return iv;case 'real':case 'numero':if(vt==="")throw new Error('Cadena vacía no es número.');const nr=parseFloat(vt);if(isNaN(nr)||!isFinite(nr)||(!/^-?\d*(\.\d+)?$/.test(vt)&&!/^-?\d+\.?$/.test(vt))){if(vt.match(/^-?\d*\.$/)){}else if(vt.match(/^-?\.\d+$/)){}else throw new Error(`'${valor}' no es número real.`);}return nr;case 'logico':const lv=vt.toLowerCase();if(lv==='verdadero'||lv==='v')return true;if(lv==='falso'||lv==='f')return false;throw new Error(`'${valor}' no es lógico.`);}}else if(typeof valor==='number'){switch(tipoDestinoLower){case 'entero':return Math.trunc(valor);case 'real':case 'numero':return valor;case 'logico':throw new Error(`${valor} no es lógico.`);}}else if(typeof valor==='boolean'){switch(tipoDestinoLower){case 'entero':return valor?1:0;case 'real':return valor?1.0:0.0;case 'numero':return valor?1:0;case 'logico':return valor;}}throw new Error(`No se puede convertir '${tipoOrigen}' a '${tipoDestinoLower}'.`);};
Webgoritmo.Interprete.inicializarArray = function(dims,baseT){const defV=this.obtenerValorPorDefecto(baseT);function cD(dI){const dS=dims[dI];if(typeof dS!=='number'||!Number.isInteger(dS)||dS<=0)throw new Error("Dim inválida.");let arr=new Array(dS+1);if(dI===dims.length-1){for(let i=1;i<=dS;i++)arr[i]=defV;}else{for(let i=1;i<=dS;i++)arr[i]=cD(dI+1);}return arr;}if(!dims||dims.length===0)throw new Error("No dims.");return cD(0);};
Webgoritmo.Interprete.parseDefinicionSubProceso = function(lineaIni,idxIni,todasLns){const rgx=/^\s*SubProceso\s+(?:([a-zA-Z_áéíóúÁÉÍÓÚñÑ][a-zA-Z0-9_áéíóúÁÉÍÓÚñÑ]*)\s*(?:<-|=)\s*)?([a-zA-Z_áéíóúÁÉÍÓÚñÑ][a-zA-Z0-9_áéíóúÁÉÍÓÚñÑ]*)\s*\((.*?)\)\s*$/i;const mH=lineaIni.trim().match(rgx);if(!mH)throw new Error(`Sintaxis SubProceso L${idxIni+1}`);const vRetO=mH[1]?mH[1].trim():null;const nomFunO=mH[2].trim();const prmsStr=mH[3].trim();const nomFunLc=nomFunO.toLowerCase();const vRetLc=vRetO?vRetO.toLowerCase():null;const prms=[];if(prmsStr){const pLst=prmsStr.split(',');for(const pS of pLst){const pT=pS.trim();if(pT==="")continue;const rgxP=/^\s*([a-zA-Z_áéíóúÁÉÍÓÚñÑ][a-zA-Z0-9_áéíóúÁÉÍÓÚñÑ]+)(?:\s+Como\s+([a-zA-Z_áéíóúÁÉÍÓÚñÑ][a-zA-Z0-9_áéíóúÁÉÍÓÚñÑ]+))?(?:\s+Por\s+Referencia)?\s*$/i;const rgxPR=/^\s*([a-zA-Z_áéíóúÁÉÍÓÚñÑ][a-zA-Z0-9_áéíóúÁÉÍÓÚñÑ]+)\s+Por\s+Referencia\s*$/i;let mP=pT.match(rgxP);let esPR=false;if(mP&&mP[0].toLowerCase().includes("por referencia"))esPR=true;else if(!mP){mP=pT.match(rgxPR);if(mP)esPR=true;}if(!mP)throw new Error(`Sintaxis param '${pT}' L${idxIni+1}.`);const pNomO=mP[1];let pTipo='desconocido';const tiposK=['entero','real','logico','caracter','cadena','numero','número','numerico','numérico'];if(mP[2]){const tPStr=mP[2];let tPLo=tPStr.toLowerCase();if(!tiposK.includes(tPLo))throw new Error(`Tipo param '${tPStr}' no reconocido L${idxIni+1}.`);pTipo=tPLo.startsWith('num')?'numero':tPLo;}prms.push({nombreOriginal:pNomO,nombreLc:pNomO.toLowerCase(),tipo:pTipo,esPorReferencia:esPR});}}const cuerpo=[];let cLN=idxIni+1;let finSOK=false;for(;cLN<todasLns.length;cLN++){const lnCO=todasLns[cLN];let lnCA=limpiarComentariosDeExpresion(lnCO.split('//')[0].trim());if(lnCA.startsWith('/*')&&lnCA.endsWith('*/'))lnCA='';const lnCL=lnCA.toLowerCase();if(lnCL.startsWith("finsubproceso")){finSOK=true;break;}cuerpo.push(lnCO);}if(!finSOK)throw new Error(`Falta 'FinSubProceso' L${idxIni+1}.`);return{nombreOriginal:nomFunO,nombreLc:nomFunLc,retornoVarOriginal:vRetO,retornoVarLc:vRetLc,parametros:prms,cuerpo:cuerpo,lineaOriginalDef:idxIni+1,indiceFinEnTodasLasLineas:cLN};};
Webgoritmo.Interprete.handleDefinir = async function(linea, ambitoActual, numLineaOriginal) { const matchDef = linea.match(/^Definir\s+([a-zA-Z_áéíóúÁÉÍÓÚñÑ][a-zA-Z0-9_áéíóúÁÉÍÓÚñÑ]*(?:\s*,\s*[a-zA-Z_áéíóúÁÉÍÓÚñÑ][a-zA-Z0-9_áéíóúÁÉÍÓÚñÑ]*)*)\s+(?:Como|Es)\s+([a-zA-Z_áéíóúÁÉÍÓÚñÑ][a-zA-Z0-9_áéíóúÁÉÍÓÚñÑ]+)(?:\s*\[\s*(.+?)\s*\])?$/i); if(!matchDef)return false; const vars=matchDef[1].split(',').map(s=>s.trim()); const tipoStr=matchDef[2]; let tipoLc=tipoStr.toLowerCase(); const dimsStrRaw=matchDef[3]; const tiposOk=['entero','real','logico','caracter','cadena','numero','número','numerico','numérico']; if(!tiposOk.includes(tipoLc))throw new Error(`Tipo '${tipoStr}' no reconocido L${numLineaOriginal}.`); if(tipoLc.startsWith("num"))tipoLc="numero"; for(const nombreVar of vars){ if(nombreVar==="")throw new Error(`Var vacía L${numLineaOriginal}.`); if(!/^[a-zA-Z_áéíóúÁÉÍÓÚñÑ][a-zA-Z0-9_áéíóúÁÉÍÓÚñÑ]*$/.test(nombreVar))throw new Error(`Var '${nombreVar}' inválida L${numLineaOriginal}.`); const nombreLc=nombreVar.toLowerCase(); if(dimsStrRaw){const dimsStrLimpio=limpiarComentariosDeExpresion(dimsStrRaw); if(dimsStrLimpio==="")throw new Error(`Dimensión vacía para '${nombreVar}' L${numLineaOriginal}.`); const dimExprs=dimsStrLimpio.split(',').map(s=>s.trim()); const evalDims=[]; for(const expr of dimExprs){if(expr==="")throw new Error(`Dimensión vacía (post-coma) para '${nombreVar}' L${numLineaOriginal}.`); let dimVal=await Webgoritmo.Expresiones.evaluarExpresion(expr,ambitoActual); if(typeof dimVal!=='number'||!Number.isInteger(dimVal)||dimVal<=0)throw new Error(`Dimensión '${expr}'->${dimVal} inválida L${numLineaOriginal}.`); evalDims.push(dimVal);} ambitoActual[nombreLc]={type:'array',baseType:tipoLc,dimensions:evalDims,value:Webgoritmo.Interprete.inicializarArray(evalDims,tipoLc),isFlexibleType:tipoLc==='numero',name:nombreVar};} else {ambitoActual[nombreLc]={value:Webgoritmo.Interprete.obtenerValorPorDefecto(tipoLc),type:tipoLc,isFlexibleType:tipoLc==='numero',name:nombreVar};}} return true;};
Webgoritmo.Interprete.handleDimension = async function(linea, ambitoActual, numLineaOriginal) { let kw=linea.trim().toLowerCase().startsWith("dimensionar")?"Dimensionar":"Dimension"; let declStr=limpiarComentariosDeExpresion(linea.trim().substring(kw.length)); if(declStr==="")throw new Error(`'${kw}' vacía L${numLineaOriginal}.`); const decls=declStr.split(','); for(let decl of decls){decl=decl.trim(); const matchArr=decl.match(/^([a-zA-Z_áéíóúÁÉÍÓÚñÑ][a-zA-Z0-9_áéíóúÁÉÍÓÚñÑ]*)\s*\[\s*(.+?)\s*\]$/i); if(!matchArr)throw new Error(`Sintaxis '${decl}' inválida L${numLineaOriginal}.`); const nombreArr=matchArr[1]; const nombreLc=nombreArr.toLowerCase(); const baseT='numero'; const flexT=true; const dimExprsStr=matchArr[2]; const dimExprs=dimExprsStr.split(',').map(s=>s.trim()); const evalDims=[]; for(const expr of dimExprs){if(expr==="")throw new Error(`Dimensión vacía (post-coma) para '${nombreArr}' L${numLineaOriginal}.`); let dimVal=await Webgoritmo.Expresiones.evaluarExpresion(expr,ambitoActual); if(typeof dimVal!=='number'||!Number.isInteger(dimVal)||dimVal<=0)throw new Error(`Dimensión '${expr}'->${dimVal} inválida L${numLineaOriginal}.`); evalDims.push(dimVal);} ambitoActual[nombreLc]={type:'array',baseType:baseT,dimensions:evalDims,value:Webgoritmo.Interprete.inicializarArray(evalDims,baseT),isFlexibleType:flexT,name:nombreArr};} return true;};
Webgoritmo.Interprete.handleEscribir = async function(linea, ambitoActual, numLineaOriginal) { const matchEsc=linea.match(/^(Escribir|Imprimir|Mostrar)\s+(.*)/i); if(!matchEsc)return false; const argsStrOrig=matchEsc[2]; const argsStrLimpia=limpiarComentariosDeExpresion(argsStrOrig); if(argsStrLimpia===""&&argsStrOrig.trim()!=="")return true; if(argsStrLimpia==="")throw new Error(`'${matchEsc[1]}' sin args L${numLineaOriginal}.`); const args=[]; let buff=""; let inDQ=false; let inSQ=false; for(let k=0;k<argsStrLimpia.length;k++){const ch=argsStrLimpia[k]; if(ch==='"'&& (k===0||argsStrLimpia[k-1]!=='\\'))inDQ=!inDQ; else if(ch==='\''&&(k===0||argsStrLimpia[k-1]!=='\\'))inSQ=!inSQ; if(ch===','&&!inDQ&&!inSQ){args.push(buff.trim());buff="";}else buff+=ch;} args.push(buff.trim()); let outParts=[]; for(const arg of args){if(arg==="")continue; const evalPart=await Webgoritmo.Expresiones.evaluarExpresion(arg,ambitoActual); outParts.push(typeof evalPart==='boolean'?(evalPart?'Verdadero':'Falso'):(evalPart===null?'nulo':String(evalPart)));} if(Webgoritmo.UI&&Webgoritmo.UI.añadirSalida)Webgoritmo.UI.añadirSalida(outParts.join(''),'normal'); return true;};
Webgoritmo.Interprete.handleAsignacion = async function(linea, ambitoActual, numLineaOriginal) { const matchAsig=linea.match(/^([a-zA-Z_áéíóúÁÉÍÓÚñÑ][a-zA-Z0-9_áéíóúÁÉÍÓÚñÑ]*(?:\s*\[.+?\])?)\s*(?:<-|=)\s*(.*)$/); if(!matchAsig)return false; const destStr=matchAsig[1].trim(); const exprStrCruda=matchAsig[2]; const exprAEval=limpiarComentariosDeExpresion(exprStrCruda); if(exprAEval==="")throw new Error(`Expresión vacía L${numLineaOriginal}.`); let evalVal=await Webgoritmo.Expresiones.evaluarExpresion(exprAEval,ambitoActual); const accArrMatch=destStr.match(/^([a-zA-Z_áéíóúÁÉÍÓÚñÑ][a-zA-Z0-9_áéíóúÁÉÍÓÚñÑ]*)\s*\[\s*(.+?)\s*\]$/); if(accArrMatch){const arrNom=accArrMatch[1]; const idxExprsStr=limpiarComentariosDeExpresion(accArrMatch[2]); const arrNomLc=arrNom.toLowerCase(); if(!ambitoActual.hasOwnProperty(arrNomLc)||ambitoActual[arrNomLc].type!=='array')throw new Error(`Arreglo '${arrNom}' no def L${numLineaOriginal}.`); const arrMeta=ambitoActual[arrNomLc]; const idxExprs=idxExprsStr.split(',').map(s=>s.trim()); if(idxExprs.some(s=>s===""))throw new Error(`Índice vacío L${numLineaOriginal}.`); if(idxExprs.length!==arrMeta.dimensions.length)throw new Error(`Dimensiones incorrectas L${numLineaOriginal}.`); const evalIdxs=[]; for(let k=0;k<idxExprs.length;k++){let idxVal=await Webgoritmo.Expresiones.evaluarExpresion(idxExprs[k],ambitoActual); if(typeof idxVal!=='number'||!Number.isInteger(idxVal)){if(typeof idxVal==='number'&&idxVal===Math.trunc(idxVal))idxVal=Math.trunc(idxVal); else throw new Error(`Índice '${idxExprs[k]}'->${idxVal} inválido L${numLineaOriginal}.`);} if(idxVal<=0||idxVal>arrMeta.dimensions[k])throw new Error(`Índice [${idxVal}] fuera de límites L${numLineaOriginal}.`); evalIdxs.push(idxVal);} let target=arrMeta.value; for(let k=0;k<evalIdxs.length-1;k++)target=target[evalIdxs[k]]; const valTipoIn=Webgoritmo.Interprete.inferirTipo(evalVal).toLowerCase(); let tipoDestConv=arrMeta.isFlexibleType&&arrMeta.baseType==='numero'?valTipoIn:arrMeta.baseType; if(arrMeta.isFlexibleType&&arrMeta.baseType==='numero'){if(valTipoIn!=='desconocido'&&valTipoIn!=='numero'){arrMeta.baseType=valTipoIn; arrMeta.isFlexibleType=false; tipoDestConv=valTipoIn;}} target[evalIdxs[evalIdxs.length-1]]=Webgoritmo.Interprete.convertirValorParaAsignacion(evalVal,tipoDestConv);} else {const varNom=destStr; if(!/^[a-zA-Z_áéíóúÁÉÍÓÚñÑ][a-zA-Z0-9_áéíóúÁÉÍÓÚñÑ]*$/.test(varNom))throw new Error(`Var '${varNom}' inválida L${numLineaOriginal}.`); const varNomLc=varNom.toLowerCase(); if(!ambitoActual.hasOwnProperty(varNomLc))throw new Error(`Var '${varNom}' no def L${numLineaOriginal}.`); const varMeta=ambitoActual[varNomLc]; if(varMeta.type==='array')throw new Error(`Asignar a arreglo completo no permitido L${numLineaOriginal}.`); const valTipoIn=Webgoritmo.Interprete.inferirTipo(evalVal).toLowerCase(); let tipoDestEsc=varMeta.isFlexibleType&&varMeta.type==='numero'?valTipoIn:varMeta.type; if(varMeta.isFlexibleType&&varMeta.type==='numero'){if(valTipoIn!=='desconocido'&&valTipoIn!=='numero'){varMeta.type=valTipoIn;varMeta.isFlexibleType=false;tipoDestEsc=valTipoIn;}} varMeta.value=Webgoritmo.Interprete.convertirValorParaAsignacion(evalVal,tipoDestEsc);} return true;};
Webgoritmo.Interprete.handleLeer = async function(linea, ambitoActual, numLineaOriginal) { const matchLeer=linea.match(/^Leer\s+(.+)/i); if(!matchLeer)throw new Error("Error interno Leer L"+numLineaOriginal); const nomsOrig=limpiarComentariosDeExpresion(matchLeer[1]).split(',').map(v=>v.trim().toLowerCase()); if(nomsOrig.length===0||nomsOrig.some(v=>v===""))throw new Error("Leer sin vars L"+numLineaOriginal); for(const nomLc of nomsOrig){const nomPrompt=limpiarComentariosDeExpresion(matchLeer[1]).split(',').map(v=>v.trim()).find(n=>n.toLowerCase()===nomLc)||nomLc; if(!/^[a-zA-Z_áéíóúÁÉÍÓÚñÑ][a-zA-Z0-9_áéíóúÁÉÍÓÚñÑ]*$/.test(nomLc))throw new Error(`Var '${nomPrompt}' inválida L${numLineaOriginal}.`); if(!ambitoActual.hasOwnProperty(nomLc))throw new Error(`Var '${nomPrompt}' no def L${numLineaOriginal}.`); if(ambitoActual[nomLc].type==='array')throw new Error(`Leer arreglo completo no soportado L${numLineaOriginal}.`);} const nomsPrompt=limpiarComentariosDeExpresion(matchLeer[1]).split(',').map(v=>v.trim()); let promptMsg=nomsPrompt.length===1?`Ingrese valor para ${nomsPrompt[0]}:`:`Ingrese ${nomsPrompt.length} valores (separados por espacio/coma) para ${nomsPrompt.join(', ')}:`; if(window.WebgoritmoGlobal&&typeof window.WebgoritmoGlobal.solicitarEntradaUsuario==='function')window.WebgoritmoGlobal.solicitarEntradaUsuario(promptMsg); else {console.error("solicitarEntradaUsuario no disponible");} Webgoritmo.estadoApp.esperandoEntrada=true; Webgoritmo.estadoApp.variableEntradaActual=nomsOrig; Webgoritmo.estadoApp.nombresOriginalesParaEntrada=nomsPrompt; Webgoritmo.estadoApp.promesaEntradaPendiente=new Promise(resolve=>{Webgoritmo.estadoApp.resolverPromesaEntrada=resolve; if(Webgoritmo.estadoApp.detenerEjecucion)resolve();}); await Webgoritmo.estadoApp.promesaEntradaPendiente; Webgoritmo.estadoApp.promesaEntradaPendiente=null; return true;};
Webgoritmo.Interprete.handleSi = async function(lineaActual, ambitoActual, numLineaOriginalSi, lineasBloqueCompleto, indiceSiEnBloque) { const siMatch=lineaActual.match(/^Si\s+(.+?)\s+Entonces$/i); if(!siMatch)throw new Error(`Error interno Si L${numLineaOriginalSi}.`); const condStrCruda=siMatch[1]; const condStrLimpia=limpiarComentariosDeExpresion(condStrCruda); if(condStrLimpia==="")throw new Error(`Condición vacía 'Si' L${numLineaOriginalSi}.`); let condVal; try{condVal=await Webgoritmo.Expresiones.evaluarExpresion(condStrLimpia,ambitoActual);}catch(e){throw new Error(`Error evaluando cond 'Si' ("${condStrLimpia}") L${numLineaOriginalSi}: ${e.message}`);} if(typeof condVal!=='boolean')throw new Error(`Cond 'Si' ("${condStrLimpia}") L${numLineaOriginalSi} debe ser lógica, no ${typeof condVal}.`); let blqEntonces=[]; let blqSino=[]; let buffActual=blqEntonces; let siAnid=0; let i=indiceSiEnBloque+1; let finSiOK=false; let enSino=false; while(i<lineasBloqueCompleto.length){if(Webgoritmo.estadoApp.detenerEjecucion)return i; const iterLineaOrig=lineasBloqueCompleto[i]; const iterLineaTrim=iterLineaOrig.trim(); const iterLineaLc=limpiarComentariosDeExpresion(iterLineaTrim.toLowerCase()); if(iterLineaLc.startsWith("si ")&&iterLineaLc.includes(" entonces")){siAnid++; buffActual.push(iterLineaOrig);}else if(iterLineaLc==="sino"){if(siAnid===0){if(enSino)throw new Error(`Múltiples 'Sino' L${numLineaOriginalSi}.`); enSino=true; buffActual=blqSino;}else{buffActual.push(iterLineaOrig);}}else if(iterLineaLc==="finsi"){if(siAnid===0){finSiOK=true; i++; break;}else{siAnid--; buffActual.push(iterLineaOrig);}}else{buffActual.push(iterLineaOrig);} i++;} if(!finSiOK)throw new Error(`Falta 'FinSi' para 'Si' L${numLineaOriginalSi}.`); if(condVal){await Webgoritmo.Interprete.ejecutarBloque(blqEntonces,ambitoActual,numLineaOriginalSi);}else{if(blqSino.length>0){await Webgoritmo.Interprete.ejecutarBloque(blqSino,ambitoActual,numLineaOriginalSi+blqEntonces.length+(enSino?1:0));}} return i-1;};
Webgoritmo.Interprete.ejecutarPseudocodigo = async function() {
    if (!Webgoritmo.UI || !Webgoritmo.UI.añadirSalida) { console.error("UI.añadirSalida no disponible."); return; }
    if (!Webgoritmo.Editor || !Webgoritmo.Editor.editorCodigo) { Webgoritmo.UI.añadirSalida("Error: Editor no listo.", "error"); return; }
    if (!Webgoritmo.estadoApp) { Webgoritmo.UI.añadirSalida("Error: estadoApp no listo.", "error"); return; }
    if (!Webgoritmo.Expresiones) { Webgoritmo.UI.añadirSalida("Error: Evaluador de expresiones no listo.", "error"); return; }
    if (Webgoritmo.DOM && Webgoritmo.DOM.consolaSalida) Webgoritmo.DOM.consolaSalida.innerHTML = '';
    Webgoritmo.UI.añadirSalida("--- Iniciando ejecución (Debug Leer v2) ---", "normal"); // Mensaje de log actualizado
    Webgoritmo.estadoApp.variables = {}; Webgoritmo.estadoApp.detenerEjecucion = false; Webgoritmo.estadoApp.errorEjecucion = null;
    Webgoritmo.estadoApp.esperandoEntrada = false; Webgoritmo.estadoApp.resolverPromesaEntrada = null; Webgoritmo.estadoApp.promesaEntradaPendiente = null;
    Webgoritmo.estadoApp.pilaLlamadas = [];
    Webgoritmo.estadoApp.lineasCodigo = Webgoritmo.Editor.editorCodigo.getValue().split('\n');
    Webgoritmo.estadoApp.funcionesDefinidas = {}; const subProcesoLineIndices = new Set();
    if (Webgoritmo.Interprete.parseDefinicionSubProceso) { for (let i = 0; i < Webgoritmo.estadoApp.lineasCodigo.length; i++) { const lineaOriginal = Webgoritmo.estadoApp.lineasCodigo[i]; let lineaParaAnalisis = limpiarComentariosDeExpresion(lineaOriginal.split('//')[0].trim()); if (lineaParaAnalisis.startsWith('/*') && lineaParaAnalisis.endsWith('*/')) lineaParaAnalisis = ''; const lineaLower = lineaParaAnalisis.toLowerCase(); if (lineaLower.startsWith("subproceso")) { try { const defSubProceso = Webgoritmo.Interprete.parseDefinicionSubProceso(lineaOriginal, i, Webgoritmo.estadoApp.lineasCodigo); if (Webgoritmo.estadoApp.funcionesDefinidas.hasOwnProperty(defSubProceso.nombreLc)) throw new Error(`SubProceso '${defSubProceso.nombreOriginal}' ya definido.`); Webgoritmo.estadoApp.funcionesDefinidas[defSubProceso.nombreLc] = defSubProceso; for (let k = i; k <= defSubProceso.indiceFinEnTodasLasLineas; k++) subProcesoLineIndices.add(k); i = defSubProceso.indiceFinEnTodasLasLineas; if (Webgoritmo.UI.añadirSalida) Webgoritmo.UI.añadirSalida(`SubProceso '${defSubProceso.nombreOriginal}' parseado (L${defSubProceso.lineaOriginalDef}).`, 'debug'); } catch (e) { Webgoritmo.estadoApp.errorEjecucion = e.message; Webgoritmo.estadoApp.detenerEjecucion = true; break; } } if (Webgoritmo.estadoApp.detenerEjecucion) break; } }
    if (Webgoritmo.estadoApp.detenerEjecucion) { if (Webgoritmo.UI.añadirSalida) { Webgoritmo.UI.añadirSalida(Webgoritmo.estadoApp.errorEjecucion, 'error'); Webgoritmo.UI.añadirSalida("--- Ejecución con errores (Parseo SubProcesos) ---", "error");} return; }
    let lineasDelPrincipal = []; let inicioBloquePrincipalLineaNum = -1; let processingState = 'buscar_inicio'; for (let j = 0; j < Webgoritmo.estadoApp.lineasCodigo.length; j++) { if (subProcesoLineIndices.has(j)) continue; const lineaOriginal = Webgoritmo.estadoApp.lineasCodigo[j]; let lineaParaAnalisis = limpiarComentariosDeExpresion(lineaOriginal.split('//')[0].trim()); if (lineaParaAnalisis.startsWith('/*') && lineaParaAnalisis.endsWith('*/')) lineaParaAnalisis = ''; const lineaLower = lineaParaAnalisis.toLowerCase(); if (processingState === 'buscar_inicio') { if (lineaLower.startsWith("proceso") || lineaLower.startsWith("algoritmo")) { inicioBloquePrincipalLineaNum = j + 1; processingState = 'en_bloque';} else if (lineaParaAnalisis !== "") { Webgoritmo.estadoApp.errorEjecucion = `Error L${j+1}: Código fuera de bloque.`; Webgoritmo.estadoApp.detenerEjecucion = true; break;} } else if (processingState === 'en_bloque') { if (lineaLower.startsWith("finproceso") || lineaLower.startsWith("finalgoritmo")) processingState = 'bloque_terminado'; else if (lineaLower.startsWith("proceso") || lineaLower.startsWith("algoritmo")) { Webgoritmo.estadoApp.errorEjecucion = `Error L${j+1}: Bloques anidados no permitidos.`; Webgoritmo.estadoApp.detenerEjecucion = true; break;} else lineasDelPrincipal.push(lineaOriginal); } else if (processingState === 'bloque_terminado') { if (lineaParaAnalisis !== "") { Webgoritmo.estadoApp.errorEjecucion = `Error L${j+1}: Código después de FinAlgoritmo.`; Webgoritmo.estadoApp.detenerEjecucion = true; break;} } }
    if (!Webgoritmo.estadoApp.errorEjecucion) { const tieneCodigoEfectivo = Webgoritmo.estadoApp.lineasCodigo.some((l, idx) => { if(subProcesoLineIndices.has(idx))return false; let t=limpiarComentariosDeExpresion(l.split('//')[0].trim()); if(t.startsWith('/*')&&t.endsWith('*/'))t=''; return t !== ''; }); if (processingState === 'buscar_inicio' && tieneCodigoEfectivo) Webgoritmo.estadoApp.errorEjecucion = "No se encontró bloque 'Algoritmo'/'Proceso'."; else if (processingState === 'en_bloque') Webgoritmo.estadoApp.errorEjecucion = `Bloque 'Algoritmo'/'Proceso' L${inicioBloquePrincipalLineaNum} no cerrado.`;}
    if (Webgoritmo.estadoApp.errorEjecucion) { if (Webgoritmo.UI.añadirSalida) Webgoritmo.UI.añadirSalida(Webgoritmo.estadoApp.errorEjecucion, 'error'); Webgoritmo.estadoApp.detenerEjecucion = true; } else if (inicioBloquePrincipalLineaNum !== -1 && processingState === 'bloque_terminado') { if (lineasDelPrincipal.length > 0) await Webgoritmo.Interprete.ejecutarBloque(lineasDelPrincipal, Webgoritmo.estadoApp.variables, inicioBloquePrincipalLineaNum -1 ); else if (Webgoritmo.UI.añadirSalida) Webgoritmo.UI.añadirSalida("Advertencia: Bloque principal vacío.", "warning"); } else { /* ... */ }
    if (Webgoritmo.UI.añadirSalida) { if (Webgoritmo.estadoApp.errorEjecucion) Webgoritmo.UI.añadirSalida("--- Ejecución con errores (Debug Leer v2) ---", "error"); else if (Webgoritmo.estadoApp.detenerEjecucion && !Webgoritmo.estadoApp.esperandoEntrada) Webgoritmo.UI.añadirSalida("--- Ejecución interrumpida (Debug Leer v2) ---", "warning");  else if (!Webgoritmo.estadoApp.esperandoEntrada) Webgoritmo.UI.añadirSalida("--- Ejecución finalizada (Debug Leer v2) ---", "normal");  }
    // ... (log de variables)
};
// ... (resto de funciones helper y handlers copiados)
console.log("motorInterprete.js (Debug Leer v2) cargado.");
